// from week 5 lecture code

import jwt from "jsonwebtoken";
import bcrypt from "bcrypt";
import validator from 'validator';
import { parsePhoneNumberFromString } from 'libphonenumber-js';
import { NextResponse } from "next/server";
import {StringValue} from "ms"
import { Prisma, PrismaClient } from "@prisma/client";
import { DefaultArgs } from "@prisma/client/runtime/library";

export function hashPassword(password: string) {
  return bcrypt.hashSync(password, parseInt(process.env.BCRYPT_ROUNDS!));
}

export function comparePassword(password: string, hash: string) {
  return bcrypt.compareSync(password, hash);
}

// from chatgpt
export function isValidEmail(email: string) {
  return validator.isEmail(email);
}

// Updated to be more lenient with phone number validation
export function isValidPhone(phone: string) {
  // If phone is empty or null, consider it valid (since it's optional)
  if (!phone || phone.trim() === '') {
    return true;
  }
  
  // Remove all non-digit characters for basic validation
  const digitsOnly = phone.replace(/\D/g, '');
  
  // Accept phone numbers with at least 7 digits (minimum for most countries)
  if (digitsOnly.length >= 7) {
    return true;
  }
  
  // Try the libphonenumber-js validation as a fallback
  try {
    const phoneNumber = parsePhoneNumberFromString(phone);
    return phoneNumber ? phoneNumber.isValid() : false;
  } catch (error) {
    // If there's any error in parsing, return false
    return false;
  }
}

// from chatgpt
export function isValidURL(url: string) {
  return validator.isURL(url);
}

type Token = {user: number}
export function generateAccessToken(object: Token): string {
  return jwt.sign(object, process.env.JWT_SECRET!, {
    expiresIn: process.env.JWT_ACCESS_EXPIRY as StringValue,
  });
}

export function generateRefreshToken(object: Token): string {
  return jwt.sign(object, process.env.JWT_SECRET!, {
    expiresIn: process.env.JWT_REFRESH_EXPIRY as StringValue,
  });
}

// generated by grok
export function verifyToken(request: Request): NextResponse<{error: string}> | Token{
  const authorization = request.headers.get('authorization');

  if (!authorization) {
    return NextResponse.json({ error: 'No authorization header provided' }, { status: 401 });
  }

  const token = authorization.replace('Bearer ', '');
  if (!token) {
    return NextResponse.json({ error: 'No token provided' }, { status: 401 });
  }

  try {
    const payload = jwt.verify(token, process.env.JWT_SECRET || 'secret');
    return payload as Token; 
  } catch (error) {
    return NextResponse.json({ error: 'Invalid or expired token' }, { status: 401 });
  }
}

export function authenticate(request: Request): Token | null {
  const authorization = request.headers.get('authorization');

  if (!authorization) {
    return null;
  }
  const token = authorization.replace('Bearer ', '');
  if (!token) {
    return null;
  }
  try {
    if (!process.env.JWT_SECRET) {
      console.error('JWT_SECRET is not set');
      return null;
    }
    const payload = jwt.verify(token, process.env.JWT_SECRET);
    return payload as Token; 
  } catch (error) {
    console.error('Token verification failed:', error);
    return null;
  }
}

// generated by grok
export function isHotelManager(authenticatedUser: any, hotelId: any, prisma: PrismaClient<Prisma.PrismaClientOptions, never, DefaultArgs>) {
  return async () => {
    if (authenticatedUser.role !== 'OWNER') {
      return false; // Not a hotel manager
    }
    if (!hotelId) {
      return true; // Manager role confirmed, no hotel-specific action
    }
    const hotel = await prisma.hotel.findUnique({
      where: { id: hotelId },
      select: { ownerId: true },
    });
    return hotel && hotel.ownerId === authenticatedUser.id; // Owns the hotel
  };
}