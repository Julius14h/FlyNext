import { authenticate } from "@/utils/auth";
import prisma from "@/utils/prisma";
import { HotelIDParam } from "@/utils/types";
import { validateParams } from "@/utils/validateParams";
import { NextResponse } from 'next/server';

// generated by grok
export async function GET(_request: Request, { params }: HotelIDParam) {
    try {
        const [hotelID, err] = validateParams((await params).hotelID)
        if (err) return err
        const hotelIdInt = Number(hotelID);

        const hotel = await prisma.hotel.findUnique({
            where: { id: hotelIdInt },
            include: {
                city: true,
                roomTypes: {
                    select: { id: true, name: true, pricePerNight: true, amenities: true },
                },
                images: {
                    select: { imageUrl: true },
                },
            },
        });

        if (!hotel) {
            return NextResponse.json({ error: 'Hotel not found' }, { status: 404 });
        }

        const response = {
            id: hotel.id,
            name: hotel.name,
            city: hotel.city ? {
              id: hotel.city.id,
              name: hotel.city.name,
              country: hotel.city.country
            } : null,
            starRating: hotel.starRating,
            amenities: hotel.amenities,
            logo: hotel.logo,
            address: hotel.address,
            latitude: hotel.latitude,
            longitude: hotel.longitude,
            images: hotel.images.map(img => img.imageUrl),
            startingPrice: hotel.roomTypes.length 
              ? Math.min(...hotel.roomTypes.map(room => room.pricePerNight))  // get lowest priced room or 0 if there is none
              : null, 
            rooms: hotel.roomTypes.map(room => ({
              id: room.id,
              type: room.name,
              pricePerNight: room.pricePerNight,
              amenities: room.amenities.split(', ').filter(Boolean), // Split string to array
            })),
          }

        return NextResponse.json(response, { status: 200 });
    } catch (error) {
        console.error('Error fetching hotel details:', error);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}

type PutBody = {
    name: string | null,
    logo: string | null,
    address: string | null,
    latitude: number | null,
    longitude: number | null,
    starRating: number | null,
    amenities: string | null,
}

export async function PUT(request: Request, { params }: HotelIDParam) {
    try {
        const token = await authenticate(request);
        if (!token) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }
        const [hotelID, err] = validateParams((await params).hotelID)
        if (err) return err
        const hotelIdInt = Number(hotelID);

        // Check if the hotel exists and belongs to the authenticated user
        const existingHotel = await prisma.hotel.findUnique({
            where: { 
                id: hotelIdInt,
                ownerId: token?.user
            },
        });
    
        if (!existingHotel) {
            return NextResponse.json({ error: 'Hotel not found or unauthorized' }, { status: 404 });
        }
    
        // Parse the request body
        const { name, address, starRating, logo, amenities, images, latitude, longitude, cityName, country } = await request.json();
        
        console.log('Updating hotel with city data:', { cityName, country });
    
        // Find or create the city
        let cityId = existingHotel.cityId;
        if (cityName && country) {
            // Try to find the city
            const city = await prisma.city.findFirst({
                where: {
                    name: cityName,
                    country: country
                }
            });
          
            if (city) {
                cityId = city.id;
            } else {
                // Create a new city if it doesn't exist
                const newCity = await prisma.city.create({
                    data: {
                        name: cityName,
                        country: country
                    }
                });
                cityId = newCity.id;
            }
        }
    
        // Update the hotel
        const updatedHotel = await prisma.hotel.update({
            where: { id: hotelIdInt },
            data: {
                name,
                address,
                starRating,
                logo,
                amenities,
                latitude,
                longitude,
                cityId,
                images: {
                    deleteMany: {}, // Delete all existing images
                    create: (images as string[]).map((imageUrl: string) => ({ imageUrl })), // Create new images
                },
            },
            include: {
                city: true,
                images: {
                    select: { imageUrl: true },
                },
            },
        });
    
        // Transform the response to match the expected format
        const response = {
            id: updatedHotel.id,
            name: updatedHotel.name,
            city: updatedHotel.city ? {
                id: updatedHotel.city.id,
                name: updatedHotel.city.name,
                country: updatedHotel.city.country
            } : null,
            starRating: updatedHotel.starRating,
            amenities: updatedHotel.amenities,
            logo: updatedHotel.logo,
            address: updatedHotel.address,
            images: updatedHotel.images.map(img => img.imageUrl),
            latitude: updatedHotel.latitude,
            longitude: updatedHotel.longitude,
        };
    
        return NextResponse.json(response, { status: 200 });
    } catch (error) {
        console.error('Error updating hotel:', error);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
}