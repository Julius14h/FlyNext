import { NextResponse } from 'next/server';
import prisma from '@/utils/prisma'; 
import { HotelIDParam } from '@/utils/types';
import { authenticate } from "@/utils/auth";

// generated from grok
export async function GET(request: Request, { params }: HotelIDParam) {
  try {
    const {hotelID} = await params;
    const { searchParams } = new URL(request.url);
    const checkIn = searchParams.get('checkIn');
    const checkOut = searchParams.get('checkOut');
    const roomTypeId = searchParams.get('roomTypeId');
    const date = searchParams.get('date');

    // Handle single room type availability check
    if (roomTypeId && date) {
      // Parse the date
      const availabilityDate = new Date(date);
      availabilityDate.setUTCHours(0, 0, 0, 0);

      if (isNaN(availabilityDate.getTime())) {
        return NextResponse.json({ error: 'Invalid date' }, { status: 400 });
      }

      // Find availability for the specific room type and date
      const availability = await prisma.roomAvailability.findFirst({
        where: {
          roomTypeId: Number(roomTypeId),
          date: availabilityDate,
        },
      });

      if (!availability) {
        return NextResponse.json({ availableRooms: 0 }, { status: 200 });
      }

      return NextResponse.json(availability, { status: 200 });
    }

    // Handle date range availability check (existing functionality)
    if (!checkIn || !checkOut) {
      return NextResponse.json(
        { error: 'Check-in and check-out dates are required for date range queries' },
        { status: 400 }
      );
    }

    //const checkInDate = new Date(checkIn);
    //const checkOutDate = new Date(checkOut);
    const checkInDate = new Date(checkIn);
    checkInDate.setUTCHours(0, 0, 0, 0);
    const checkOutDate = new Date(checkOut);
    checkOutDate.setUTCHours(0, 0, 0, 0);
    if (isNaN(checkInDate.getTime()) || isNaN(checkOutDate.getTime()) || checkInDate >= checkOutDate) {
      return NextResponse.json({ error: 'Invalid date range' }, { status: 400 });
    }


    // Get all room types for the hotel with their availability counts
    const roomTypes = await prisma.roomType.findMany({
      where: {
        hotelId: Number(hotelID),
      },
      include: {
        availabilities: {
          where: {
            date: {
              gte: checkInDate,
              lte: checkOutDate,
            },
          },
          select: {
            date: true,
            availableRooms: true,
          },
        },
      },
    });

    // Calculate availability for each room type over the full date range
    const days = (checkOutDate.getTime() - checkInDate.getTime()) / (1000 * 60 * 60 * 24) + 1; // Include both start and end days
    const availableRoomTypes = roomTypes
      .filter(roomType => {
        // Must have availability records for every day in the range
        return roomType.availabilities.length === days && 
               roomType.availabilities.every(a => a.availableRooms > 0);
      })
      .map(roomType => {
        // Minimum available rooms across all days
        const minAvailable = Math.min(...roomType.availabilities.map(a => a.availableRooms));
        return {
          id: roomType.id,
          type: roomType.name,
          price: roomType.pricePerNight,
          amenities: roomType.amenities.split(', ').filter(Boolean),
          quantity: minAvailable, // Number of rooms available for the entire stay
        };
      });

    if (availableRoomTypes.length === 0) {
      return NextResponse.json(
        { message: 'No rooms available for the selected dates' },
        { status: 200 }
      );
    }

    return NextResponse.json(availableRoomTypes, { status: 200 });
  } catch (error) {
    console.error('Error checking room availability:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}
// generated by cursor
// Update room availability
export async function PUT(request: Request, { params }: HotelIDParam) {
  try {
    // Authenticate the user
    const user = await authenticate(request);
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { hotelID } = await params;
    const hotelIdInt = Number(hotelID);

    // Check if the hotel exists and belongs to the authenticated user
    const hotel = await prisma.hotel.findUnique({
      where: { 
        id: hotelIdInt,
        ownerId: user.user
      },
    });

    if (!hotel) {
      return NextResponse.json({ error: 'Hotel not found or unauthorized' }, { status: 404 });
    }

    // Parse the request body
    const { roomTypeId, date, availableRooms } = await request.json();

    if (!roomTypeId || !date || availableRooms === undefined) {
      return NextResponse.json(
        { error: 'Room type ID, date, and available rooms count are required' },
        { status: 400 }
      );
    }

    // Check if the room type exists and belongs to the hotel
    const roomType = await prisma.roomType.findUnique({
      where: { 
        id: Number(roomTypeId),
        hotelId: hotelIdInt
      },
    });

    if (!roomType) {
      return NextResponse.json({ error: 'Room type not found' }, { status: 404 });
    }

    // Parse the date
    const availabilityDate = new Date(date);
    availabilityDate.setUTCHours(0, 0, 0, 0);

    if (isNaN(availabilityDate.getTime())) {
      return NextResponse.json({ error: 'Invalid date' }, { status: 400 });
    }

    // Check if availability record exists for this date and room type
    const existingAvailability = await prisma.roomAvailability.findFirst({
      where: {
        roomTypeId: Number(roomTypeId),
        date: availabilityDate,
      },
    });

    let updatedAvailability;

    if (existingAvailability) {
      // Update existing availability
      updatedAvailability = await prisma.roomAvailability.update({
        where: { id: existingAvailability.id },
        data: { availableRooms: Number(availableRooms) },
      });
    } else {
      // Create new availability
      updatedAvailability = await prisma.roomAvailability.create({
        data: {
          roomTypeId: Number(roomTypeId),
          date: availabilityDate,
          availableRooms: Number(availableRooms),
        },
      });
    }

    return NextResponse.json(updatedAvailability, { status: 200 });
  } catch (error) {
    console.error('Error updating room availability:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}